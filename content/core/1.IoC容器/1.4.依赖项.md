# 依赖项

- [1.4.依赖项](#1.4.依赖项)
     - [1.4.1.依赖注入](#1.4.1.依赖注入)
         - [基于构造函数的依赖注入](#基于构造函数的依赖注入)
         - [基于Setter的依赖注入]()
         - [依赖解析过程]()
         - [依赖注入示例]()
     - [1.4.2.依赖和配置的详细信息]()
     - [1.4.3.使用依赖]()
     - [1.4.4.懒加载初始化Bean]()
     - [1.4.5.自动装配协作器]()
     - [1.4.6.方法注入]()
     
### 1.4.依赖项
经典的企业级应用系统不单单包含单个对象(或Spring的Bean)。
即使是使用最简单的应用程序，也有一些对象可以协同工作，以呈现一个完整应用程序给终端用户。
下个部分将说明如何定义多个独立的Bean定义到实现对象协作达成目标，并实现整个应用程序。

#### 1.4.1.依赖注入
依赖注入(DI)是一个过程，通过该过程对象可以定义其依赖关系(即，与它们一工作的其他对象)，该过程可以通过构造方法参数，工厂方法参数，或从工厂方法构造或返回后的对象实例上设置的属性。
然后，容器在创建Bean时注入那些依赖项。
从根本上讲，此过程是通过使用类的直接构造器或服务定位器模式来控制Bean自身依赖关系的实例化或其依赖项的位置的逆过程（因此成为控制反转）。

使用DI原理，代码更加简洁，当为对象提供依赖项时，去耦合会更加有效。
该对象不查找其依赖项，也不知道一辆项的位置或Class。
带来的结果是类变得更易于测试，尤其是在当已联系概念股依赖于接口或抽象基类时，他们允许在单元测试中使用存根或模拟实现。

DI存在两个主要变体：“基于构造函数的依赖注入”和“基于Setter的依赖注入”

###### 基于构造函数的依赖注入
基于构造函数的DI是通过容器调用具有多个参数(每个参数代表一个依赖项)的构造函数来完成的。
几乎等效于调用带有特定参数的`static`工厂方法来构造Bean，并且本次讨论将构造函数的参数和`static`工厂方法的参数视为相同。
以下示例显示了只通过构造函数进行依赖注入的类：

    public class SimpleMovieLister {

        // the SimpleMovieLister has a dependency on a MovieFinder
        private MovieFinder movieFinder;

        // a constructor so that the Spring container can inject a MovieFinder
        public SimpleMovieLister(MovieFinder movieFinder) {
            this.movieFinder = movieFinder;
        }

        // business logic that actually uses the injected MovieFinder is omitted...
    }

注意，该类没有什么特别的。
它是一个POJO，不依赖于容器的特殊接口，基类或注释。

###### 构造函数参数解析
构造函数参数解析通过使用参数的类型进行匹配。
如果Bean定义的构造函数参数中不存在潜在的歧义，则在实例化Bean时，在Bean定义构造函数参数的顺序，就是将这些参数提供给构造函数的顺序。
研究以下class：

    package x.y;

    public class ThingOne {

        public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
            // ...
        }
    }

假设ThingTwo和ThingThree没有继承关系，则不存在潜在的歧义。
因此，以下配置可以正常工作，并且无需再`<constructor-arg/>`元素中显式指定构造函数参数索引或类型。

    <beans>
        <bean id="beanOne" class="x.y.ThingOne">
           <constructor-arg ref="beanTwo"/>
            <constructor-arg ref="beanThree"/>
        </bean>

        <bean id="beanTwo" class="x.y.ThingTwo"/>

        <bean id="beanThree" class="x.y.ThingThree"/>
    </beans>

当引用另一个Bean是，类型是已知的，并且可以匹配(与前面的实例一样)。
当使用简单类型时，Spring无法确定值的类型，在没有帮助的情况下无法按类型进行匹配。
研究以下Class：

    package examples;

    public class ExampleBean {

        // Number of years to calculate the Ultimate Answer
        private int years;

        // The Answer to Life, the Universe, and Everything
        private String ultimateAnswer;

        public ExampleBean(int years, String ultimateAnswer) {
           this.years = years;
           this.ultimateAnswer = ultimateAnswer;
        }
    }

###### 构造函数参数类型匹配·

#### 1.4.2.依赖项和配置细节